<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Time Slider Map with Track Line</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
/>

<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<style>
  #map { height: 70vh; }
  #controls {
    width: 90%;
    margin: 10px auto;
    text-align: center;
  }
.media-popup img {
  max-width: 200px;
  max-height: 150px;
  width: auto;
  height: auto;
  display: block;
  margin-bottom: 6px;
  border-radius: 6px;
}
  #controls input {
    margin: 5px;
    padding: 5px;
  }
#timestamp {
  font-size: 1.4em;
  font-weight: bold;
  margin-top: 10px;
  line-height: 1.4;
}

.date-part {
  color: #444;
  font-size: 1.2em;
}

.time-part {
  color: #000;
  font-size: 1.6em;
}
</style>
</head>
<body>

<div id="map"></div>

<div id="controls">

  <!-- Date Range -->
  <label>Start Date:</label>
  <input type="date" id="startDate">

  <label>End Date:</label>
  <input type="date" id="endDate">

  <br><br>

  <!-- Hour Range -->
  <label>Start Hour:</label>
  <input type="number" id="startHour" min="0" max="23" value="0">

  <label>End Hour:</label>
  <input type="number" id="endHour" min="0" max="23" value="23">

  <br><br>

  <!-- Slider -->
  <input id="timeSlider" type="range" min="0" max="0" value="0" style="width:100%;">
  <div id="timestamp" style="text-align:center; margin-top:5px;"></div>
</div>

<script>
const BOUNDS = [25, 90, 46, 145];
const TXT_URL = "https://raw.githubusercontent.com/Wiznerd1/Japan2025.github.io/main/location_log.txt";
const MEDIA_API_URL = "https://script.google.com/macros/s/AKfycbyc9joIuKOjZZZ5sNc_gEsHC1-V6ypyALjsAOEmaYRLNwFUaQvpsbfhRwunAdI0af3i/exec";

// Leaflet map
const map = L.map('map').setView([1.298, 103.776], 13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);


// Raw data arrays
let mediaCluster = L.markerClusterGroup({
  spiderfyOnMaxZoom: true,
  showCoverageOnHover: false,
  maxClusterRadius: 40
});
let mediaItems = [];
let mediaMarkers = [];
let coords = [];
let timestamps = [];
map.addLayer(mediaCluster);
// Filtered arrays
let filteredCoords = [];
let filteredTimestamps = [];

// Markers
let marker = null;
let startMarker = null;
let endMarker = null;
let polyline = null;

// Custom icons for start/end
const startIcon = L.icon({
    iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png",
    shadowUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png",
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
});

const endIcon = L.icon({
    iconUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png",
    shadowUrl: "https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png",
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
});

// UI elements
let slider = document.getElementById("timeSlider");
let tsLabel = document.getElementById("timestamp");
let startDateInput = document.getElementById("startDate");
let endDateInput = document.getElementById("endDate");
let startHourInput = document.getElementById("startHour");
let endHourInput = document.getElementById("endHour");

// Load the location log
fetch(TXT_URL)
  .then(res => res.text())
  .then(text => {
    const lines = text.split("\n");
    const uniqueDates = new Set();

    lines.forEach(line => {
      line = line.trim();
      if (!line) return;
      const parts = line.split(": ");
      if (parts.length !== 2) return;

      const time = new Date(parts[0]);
      const [latStr, lonStr] = parts[1].split(", ");

      coords.push([parseFloat(latStr), parseFloat(lonStr)]);
      timestamps.push(time);

      uniqueDates.add(parts[0].split(" ")[0]);
    });

    // Pre-fill date inputs
    const dateList = [...uniqueDates].sort();
    if (dateList.length > 0) {
      startDateInput.value = dateList[0];
      endDateInput.value = dateList[dateList.length - 1];
    }

    applyFilters();
fetch(MEDIA_API_URL)
  .then(res => res.json())
  .then(data => {
    mediaItems = data;
    placeMediaMarkers();
  });
  });

// Filter function
function findNearestLocation(targetTime) {
  let bestIndex = -1;
  let smallestDiff = Infinity;

  for (let i = 0; i < timestamps.length; i++) {
    const diff = Math.abs(timestamps[i] - targetTime);
    if (diff < smallestDiff) {
      smallestDiff = diff;
      bestIndex = i;
    }
  }

  return bestIndex >= 0 ? coords[bestIndex] : null;
}
function placeMediaMarkers() {
  // Clear old markers
  mediaCluster.clearLayers();
mediaMarkers = [];

  mediaItems.forEach(item => {
    let lat = item.latitude;
    let lon = item.longitude;


    // If no GPS, use nearest timeline location
    if (lat == null || lon == null) {
      const timeStr = item.exifTime || item.createdTime;
      if (!timeStr) return;

      const nearest = findNearestLocation(new Date(timeStr));
      if (!nearest) return;

      lat = nearest[0];
      lon = nearest[1];
    }

    // Bounds check (reuse your existing constraint)
    if (
      lat < BOUNDS[0] || lat > BOUNDS[1] ||
      lon < BOUNDS[2] || lon > BOUNDS[3]
    ) return;

const isImage =
  item.mimeType?.startsWith("image/") ||
  /\.(jpe?g|png|gif|webp)$/i.test(item.downloadUrl);

const thumbUrl = item.fileId
  ? `https://drive.google.com/thumbnail?id=${item.fileId}&sz=w400`
  : null;

const previewHtml = thumbUrl
  ? `<img src="${thumbUrl}" loading="lazy">`
  : "";

const popupHtml = `
  <div class="media-popup">
    ${previewHtml}
    <strong>${item.name || "Media"}</strong><br>
    <a href="${item.downloadUrl}" target="_blank">Open</a><br>
    <small>${item.exifTime || item.createdTime || ""}</small>
  </div>
`;
    const marker = L.marker([lat, lon])
      .bindPopup(popupHtml);
marker.on("popupopen", e => {
  const imgs = e.popup.getElement().querySelectorAll("img");
  imgs.forEach(img => {
    img.onload = () => e.popup.update();
  });
});
mediaCluster.addLayer(marker);
    mediaMarkers.push(marker);
  });
}

function applyFilters() {
  const startDateVal = startDateInput.value ? new Date(startDateInput.value + "T00:00:00") : null;
  const endDateVal = endDateInput.value ? new Date(endDateInput.value + "T23:59:59") : null;
  const startHour = parseInt(startHourInput.value);
  const endHour = parseInt(endHourInput.value);

  filteredCoords = [];
  filteredTimestamps = [];

  for (let i = 0; i < timestamps.length; i++) {
    const t = timestamps[i];
    const hour = t.getHours();
    const [lat, lon] = coords[i];

    // Date range filter
    if (startDateVal && t < startDateVal) continue;
    if (endDateVal && t > endDateVal) continue;

    // Hour range filter
    if (hour < startHour || hour > endHour) continue;

    // --- LOCATION FILTER ---
    if (lat < BOUNDS[0] || lat > BOUNDS[1] || lon < BOUNDS[2] || lon > BOUNDS[3]) continue;

    // Skip if location is identical to previous accepted point
if (filteredCoords.length > 0) {
    const [prevLat, prevLon] = filteredCoords[filteredCoords.length - 1];
    if (prevLat === lat && prevLon === lon) continue;
}

filteredCoords.push([lat, lon]);
filteredTimestamps.push(t);
}


  redrawMap();
}

// Redraw polyline and markers
function redrawMap() {
  if (polyline) map.removeLayer(polyline);
  if (marker) { map.removeLayer(marker); marker = null; }
  if (startMarker) map.removeLayer(startMarker);
  if (endMarker) map.removeLayer(endMarker);

  if (filteredCoords.length === 0) {
    tsLabel.textContent = "No data for this selection";
    slider.max = 0;
    slider.value = 0;
    return;
  }

  polyline = L.polyline(filteredCoords, {color: 'blue', weight: 3}).addTo(map);
  map.fitBounds(polyline.getBounds());

  // Start and end markers
  startMarker = L.marker(filteredCoords[0], {icon: startIcon}).addTo(map);
  endMarker = L.marker(filteredCoords[filteredCoords.length - 1], {icon: endIcon}).addTo(map);

  slider.min = 0;
  slider.max = filteredCoords.length - 1;
  slider.value = 0;

  updateMarker(0);
}

// Update moving marker
function updateMarker(i) {
  if (!filteredCoords[i]) return;

  if (!marker) marker = L.marker(filteredCoords[i]).addTo(map);
  else marker.setLatLng(filteredCoords[i]);

  const t = filteredTimestamps[i];

  // Separate date and time for readability
  const dateStr = t.toLocaleDateString();
  const timeStr = t.toLocaleTimeString([], {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });

  tsLabel.innerHTML = `
    <div class="date-part">${dateStr}</div>
    <div class="time-part">${timeStr}</div>
  `;
}

// Slider control
slider.addEventListener("input", () => {
  updateMarker(parseInt(slider.value));
});

// Event listeners for filters
startDateInput.addEventListener("change", applyFilters);
endDateInput.addEventListener("change", applyFilters);
startHourInput.addEventListener("change", applyFilters);
endHourInput.addEventListener("change", applyFilters);

</script>
</body>
</html>